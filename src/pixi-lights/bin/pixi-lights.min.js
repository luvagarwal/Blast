!function e(t,r,i){function n(a,l){if(!r[a]){if(!t[a]){var s="function"==typeof require&&require;if(!l&&s)return s(a,!0);if(o)return o(a,!0);var h=new Error("Cannot find module '"+a+"'");throw h.code="MODULE_NOT_FOUND",h}var u=r[a]={exports:{}};t[a][0].call(u.exports,function(e){var r=t[a][1][e];return n(r?r:e)},u,u.exports,e,t,r,i)}return r[a].exports}for(var o="function"==typeof require&&require,a=0;a<i.length;a++)n(i[a]);return n}({1:[function(e,t,r){t.exports=PIXI.lights={Light:e("./lights/light/Light"),LightShader:e("./lights/light/LightShader"),AmbientLight:e("./lights/ambientLight/AmbientLight"),AmbientLightShader:e("./lights/ambientLight/AmbientLightShader"),PointLight:e("./lights/pointLight/PointLight"),PointLightShader:e("./lights/pointLight/PointLightShader"),DirectionalLight:e("./lights/directionalLight/DirectionalLight"),DirectionalLightShader:e("./lights/directionalLight/DirectionalLightShader"),LightRenderer:e("./renderers/LightRenderer"),WebGLDeferredRenderer:e("./renderers/WebGLDeferredRenderer"),WireframeShader:e("./lights/WireframeShader")},e("./lightSpriteMixin"),e("./shapeMeshMixin")},{"./lightSpriteMixin":2,"./lights/WireframeShader":3,"./lights/ambientLight/AmbientLight":4,"./lights/ambientLight/AmbientLightShader":5,"./lights/directionalLight/DirectionalLight":6,"./lights/directionalLight/DirectionalLightShader":7,"./lights/light/Light":8,"./lights/light/LightShader":9,"./lights/pointLight/PointLight":10,"./lights/pointLight/PointLightShader":11,"./renderers/LightRenderer":12,"./renderers/WebGLDeferredRenderer":13,"./shapeMeshMixin":14}],2:[function(e,t,r){PIXI.Sprite.prototype._renderWebGL=function(e){if(this._originalTexture||(this._originalTexture=this._texture),e.renderingUnlit){if(this.normalTexture)return;this._texture=this._originalTexture}else if(e.renderingNormals){if(!this.normalTexture)return;this._texture=this.normalTexture}else this._texture=this._originalTexture;e.setObjectRenderer(e.plugins.sprite),e.plugins.sprite.render(this)}},{}],3:[function(e,t,r){function i(e){PIXI.Shader.call(this,e,["precision lowp float;","attribute vec2 aVertexPosition;","uniform mat3 projectionMatrix;","void main(void) {","    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);","}"].join("\n"),["void main() {","    gl_FragColor = vec4(0, 0, 0, 1);","}"].join("\n"),{translationMatrix:{type:"mat3",value:new Float32Array(9)},projectionMatrix:{type:"mat3",value:new Float32Array(9)}},{aVertexPosition:0})}i.prototype=Object.create(PIXI.Shader.prototype),i.prototype.constructor=i,t.exports=i,PIXI.ShaderManager.registerPlugin("wireframeShader",i)},{}],4:[function(e,t,r){function i(e,t){n.call(this,e,t),this.shaderName="ambientLightShader"}var n=e("../light/Light");i.prototype=Object.create(n.prototype),i.prototype.constructor=i,t.exports=i,i.prototype.renderWebGL=function(e){e.renderingNormals&&e.plugins.lights.render(this)}},{"../light/Light":8}],5:[function(e,t,r){function i(e){n.call(this,e,null,'#define GLSLIFY 1\nprecision lowp float;\n\nuniform sampler2D uSampler;\nuniform sampler2D uNormalSampler;\n\nuniform mat3 translationMatrix;\n\nuniform vec2 uViewSize;     // size of the viewport\n\nuniform vec4 uLightColor;   // light color, alpha channel used for intensity.\nuniform vec3 uLightFalloff; // light attenuation coefficients (constant, linear, quadratic)\nuniform float uLightHeight; // light height above the viewport\n\n\nvoid main(void)\n{\nvec2 texCoord = gl_FragCoord.xy / uViewSize;\ntexCoord.y = 1.0 - texCoord.y; // FBOs positions are flipped.\n\nvec4 normalColor = texture2D(uNormalSampler, texCoord);\nnormalColor.g = 1.0 - normalColor.g; // Green layer is flipped Y coords.\n\n// bail out early when normal has no data\nif (normalColor.a == 0.0) discard;\n\n\n    // simplified lambert shading that makes assumptions for ambient color\n\n    // compute Distance\n    float D = 1.0;\n    \n    // normalize vectors\n    vec3 N = normalize(normalColor.xyz * 2.0 - 1.0);\n    vec3 L = vec3(1.0, 1.0, 1.0);\n    \n    // pre-multiply light color with intensity\n    // then perform "N dot L" to determine our diffuse\n    vec3 diffuse = (uLightColor.rgb * uLightColor.a) * max(dot(N, L), 0.0);\n\n    vec4 diffuseColor = texture2D(uSampler, texCoord);\n    vec3 finalColor = diffuseColor.rgb * diffuse;\n\n    gl_FragColor = vec4(finalColor, diffuseColor.a);\n}\n')}var n=e("../light/LightShader");i.prototype=Object.create(n.prototype),i.prototype.constructor=i,t.exports=i,PIXI.ShaderManager.registerPlugin("ambientLightShader",i)},{"../light/LightShader":9}],6:[function(e,t,r){function i(e,t,r){n.call(this,e,t),this.target=r,this._directionVector=new PIXI.Point,this._updateTransform=n.prototype.updateTransform,this._syncShader=n.prototype.syncShader,this.shaderName="directionalLightShader"}var n=e("../light/Light");i.prototype=Object.create(n.prototype),i.prototype.constructor=i,t.exports=i,i.prototype.updateTransform=function(){this._updateTransform();var e=this._directionVector,t=this.worldTransform,r=this.target.worldTransform?this.target.worldTransform.tx:this.target.x,i=this.target.worldTransform?this.target.worldTransform.ty:this.target.y;e.x=t.tx-r,e.y=t.ty-i;var n=Math.sqrt(e.x*e.x+e.y*e.y);e.x/=n,e.y/=n},i.prototype.syncShader=function(e){this._syncShader(e),e.uniforms.uLightDirection.value[0]=this._directionVector.x,e.uniforms.uLightDirection.value[1]=this._directionVector.y}},{"../light/Light":8}],7:[function(e,t,r){function i(e){n.call(this,e,null,'#define GLSLIFY 1\nprecision lowp float;\n\n// imports the common uniforms like samplers, and ambient/light color\nuniform sampler2D uSampler;\nuniform sampler2D uNormalSampler;\n\nuniform mat3 translationMatrix;\n\nuniform vec2 uViewSize;     // size of the viewport\n\nuniform vec4 uLightColor;   // light color, alpha channel used for intensity.\nuniform vec3 uLightFalloff; // light attenuation coefficients (constant, linear, quadratic)\nuniform float uLightHeight; // light height above the viewport\n\n\nuniform vec2 uLightDirection;\n\nvoid main()\n{\nvec2 texCoord = gl_FragCoord.xy / uViewSize;\ntexCoord.y = 1.0 - texCoord.y; // FBOs positions are flipped.\n\nvec4 normalColor = texture2D(uNormalSampler, texCoord);\nnormalColor.g = 1.0 - normalColor.g; // Green layer is flipped Y coords.\n\n// bail out early when normal has no data\nif (normalColor.a == 0.0) discard;\n\n\n    // the directional vector of the light\n    vec3 lightVector = vec3(uLightDirection, uLightHeight);\n\n    // compute Distance\n    float D = length(lightVector);\n\n// normalize vectors\nvec3 N = normalize(normalColor.xyz * 2.0 - 1.0);\nvec3 L = normalize(lightVector);\n\n// pre-multiply light color with intensity\n// then perform "N dot L" to determine our diffuse\nvec3 diffuse = (uLightColor.rgb * uLightColor.a) * max(dot(N, L), 0.0);\n\n\n    // calculate attenuation\n    float attenuation = 1.0;\n\n// calculate final intesity and color, then combine\nvec3 intensity = diffuse * attenuation;\nvec4 diffuseColor = texture2D(uSampler, texCoord);\nvec3 finalColor = diffuseColor.rgb * intensity;\n\ngl_FragColor = vec4(finalColor, diffuseColor.a);\n\n}\n',{uLightDirection:{type:"2f",value:new Float32Array(2)}})}var n=e("../light/LightShader");i.prototype=Object.create(n.prototype),i.prototype.constructor=i,t.exports=i,PIXI.ShaderManager.registerPlugin("directionalLightShader",i)},{"../light/LightShader":9}],8:[function(e,t,r){function i(e,t,r,n){if(this.constructor===i)throw new Error("Light is an abstract base class, it should not be created directly!");PIXI.DisplayObject.call(this),this.vertices=r||new Float32Array(8),this.indices=n||new Uint16Array([0,1,2,0,2,3]),this.blendMode=PIXI.BLEND_MODES.ADD,this.drawMode=PIXI.DRAW_MODES.TRIANGLES,this.needsUpdate=!0,this.height=.075,this.falloff=[.75,3,20],this.shaderName=null,this.useViewportQuad=!0,this.visible=!1,this._vertexBuffer=null,this._indexBuffer=null,this._color=5066073,this._colorRgba=[.3,.3,.35,.8],(e||0===e)&&(this.color=e),(t||0===t)&&(this.brightness=t)}i.prototype=Object.create(PIXI.DisplayObject.prototype),i.prototype.constructor=i,t.exports=i,Object.defineProperties(i.prototype,{color:{get:function(){return this._color},set:function(e){this._color=e,PIXI.utils.hex2rgb(e,this._colorRgba)}},brightness:{get:function(){return this._colorRgba[3]},set:function(e){this._colorRgba[3]=e}}}),i.prototype.syncShader=function(e){e.uniforms.uUseViewportQuad.value=this.useViewportQuad,e.uniforms.uLightColor.value[0]=this._colorRgba[0],e.uniforms.uLightColor.value[1]=this._colorRgba[1],e.uniforms.uLightColor.value[2]=this._colorRgba[2],e.uniforms.uLightColor.value[3]=this._colorRgba[3],e.uniforms.uLightHeight.value=this.height,e.uniforms.uLightFalloff.value[0]=this.falloff[0],e.uniforms.uLightFalloff.value[1]=this.falloff[1],e.uniforms.uLightFalloff.value[2]=this.falloff[2]},i.prototype.renderWebGL=function(e){e.renderingNormals&&e.plugins.lights.render(this)},i.prototype.destroy=function(){PIXI.DisplayObject.prototype.destroy.call(this)},i.DRAW_MODES={}},{}],9:[function(e,t,r){function i(e,t,r,n,o){var a={translationMatrix:{type:"mat3",value:new Float32Array(9)},projectionMatrix:{type:"mat3",value:new Float32Array(9)},uSampler:{type:"sampler2D",value:null},uNormalSampler:{type:"sampler2D",value:null},uUseViewportQuad:{type:"bool",value:!0},uViewSize:{type:"2f",value:new Float32Array(2)},uLightColor:{type:"4f",value:new Float32Array([1,1,1,1])},uLightFalloff:{type:"3f",value:new Float32Array([0,0,0])},uLightHeight:{type:"1f",value:.075}};if(n)for(var l in n)a[l]=n[l];var s={aVertexPosition:0};if(o)for(var h in o)s[h]=o[h];PIXI.Shader.call(this,e,t||i.defaultVertexSrc,r,a,s)}i.prototype=Object.create(PIXI.Shader.prototype),i.prototype.constructor=i,t.exports=i,i.defaultVertexSrc="#define GLSLIFY 1\nprecision lowp float;\n\nattribute vec2 aVertexPosition;\n\nuniform bool uUseViewportQuad;\nuniform mat3 translationMatrix;\nuniform mat3 projectionMatrix;\n\nvoid main(void) {\n    if (uUseViewportQuad) {\n        gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    }\n    else\n    {\n        gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    }\n}\n"},{}],10:[function(e,t,r){function i(e,t,r){if(r=r||1/0,r!==1/0){var i=new PIXI.Circle(0,0,r),o=i.getMesh();n.call(this,e,t,o.vertices,o.indices),this.useViewportQuad=!1,this.drawMode=PIXI.DRAW_MODES.TRIANGLE_FAN}else n.call(this,e,t);this._syncShader=n.prototype.syncShader,this.radius=r,this.shaderName="pointLightShader"}var n=e("../light/Light");i.prototype=Object.create(n.prototype),i.prototype.constructor=i,t.exports=i,i.prototype.syncShader=function(e){this._syncShader(e),e.uniforms.uLightRadius.value=this.radius}},{"../light/Light":8}],11:[function(e,t,r){function i(e){n.call(this,e,null,'#define GLSLIFY 1\nprecision lowp float;\n\n// imports the common uniforms like samplers, and ambient color\nuniform sampler2D uSampler;\nuniform sampler2D uNormalSampler;\n\nuniform mat3 translationMatrix;\n\nuniform vec2 uViewSize;     // size of the viewport\n\nuniform vec4 uLightColor;   // light color, alpha channel used for intensity.\nuniform vec3 uLightFalloff; // light attenuation coefficients (constant, linear, quadratic)\nuniform float uLightHeight; // light height above the viewport\n\n\nuniform float uLightRadius;\n\nvoid main()\n{\nvec2 texCoord = gl_FragCoord.xy / uViewSize;\ntexCoord.y = 1.0 - texCoord.y; // FBOs positions are flipped.\n\nvec4 normalColor = texture2D(uNormalSampler, texCoord);\nnormalColor.g = 1.0 - normalColor.g; // Green layer is flipped Y coords.\n\n// bail out early when normal has no data\nif (normalColor.a == 0.0) discard;\n\n\n    vec2 lightPosition = translationMatrix[2].xy / uViewSize;\n\n    // the directional vector of the light\n    vec3 lightVector = vec3(lightPosition - texCoord, uLightHeight);\n\n    // correct for aspect ratio\n    lightVector.x *= uViewSize.x / uViewSize.y;\n\n    // compute Distance\n    float D = length(lightVector);\n\n    // bail out early when pixel outside of light sphere\n    if (D > uLightRadius) discard;\n\n// normalize vectors\nvec3 N = normalize(normalColor.xyz * 2.0 - 1.0);\nvec3 L = normalize(lightVector);\n\n// pre-multiply light color with intensity\n// then perform "N dot L" to determine our diffuse\nvec3 diffuse = (uLightColor.rgb * uLightColor.a) * max(dot(N, L), 0.0);\n\n\n    // calculate attenuation\n    float attenuation = 1.0 / (uLightFalloff.x + (uLightFalloff.y * D) + (uLightFalloff.z * D * D));\n\n// calculate final intesity and color, then combine\nvec3 intensity = diffuse * attenuation;\nvec4 diffuseColor = texture2D(uSampler, texCoord);\nvec3 finalColor = diffuseColor.rgb * intensity;\n\ngl_FragColor = vec4(finalColor, diffuseColor.a);\n\n}',{uLightRadius:{type:"1f",value:1}})}var n=e("../light/LightShader");i.prototype=Object.create(n.prototype),i.prototype.constructor=i,t.exports=i,PIXI.ShaderManager.registerPlugin("pointLightShader",i)},{"../light/LightShader":9}],12:[function(e,t,r){function i(e){PIXI.ObjectRenderer.call(this,e);var t=6*i.MAX_LIGHTS;this.indices=new Uint16Array(t);for(var r=0,n=0;t>r;r+=6,n+=4)this.indices[r+0]=n+0,this.indices[r+1]=n+1,this.indices[r+2]=n+2,this.indices[r+3]=n+0,this.indices[r+4]=n+2,this.indices[r+5]=n+3;this.currentBatchSize=0,this.lights=[]}i.MAX_LIGHTS=500,i.prototype=Object.create(PIXI.ObjectRenderer.prototype),i.prototype.constructor=i,t.exports=i,PIXI.WebGLRenderer.registerPlugin("lights",i),i.prototype.render=function(e){this.lights[this.currentBatchSize++]=e},i.prototype.flush=function(){for(var e=this.renderer,t=e.gl,r=e.diffuseTexture,i=e.normalsTexture,n=null,o=0;o<this.currentBatchSize;++o){var a=this.lights[o],l=a.shader||this.renderer.shaderManager.plugins[a.shaderName];a._vertexBuffer||this._initWebGL(a),l!==n&&(n=l,e.shaderManager.setShader(l)),e.blendModeManager.setBlendMode(a.blendMode),l.uniforms.uViewSize.value[0]=e.width,l.uniforms.uViewSize.value[1]=e.height,a.worldTransform.toArray(!0,l.uniforms.translationMatrix.value),e.currentRenderTarget.projectionMatrix.toArray(!0,l.uniforms.projectionMatrix.value),a.useViewportQuad&&(a.vertices[2]=a.vertices[4]=e.width,a.vertices[5]=a.vertices[7]=e.height),a.syncShader(l),l.syncUniforms(),t.uniform1i(l.uniforms.uSampler._location,0),t.uniform1i(l.uniforms.uNormalSampler._location,1),a.needsUpdate?(a.needsUpdate=!1,t.bindBuffer(t.ARRAY_BUFFER,a._vertexBuffer),t.bufferData(t.ARRAY_BUFFER,a.vertices,t.STATIC_DRAW),t.vertexAttribPointer(l.attributes.aVertexPosition,2,t.FLOAT,!1,0,0),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,r.baseTexture._glTextures[t.id]),t.activeTexture(t.TEXTURE1),t.bindTexture(t.TEXTURE_2D,i.baseTexture._glTextures[t.id]),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,a._indexBuffer),t.bufferData(t.ELEMENT_ARRAY_BUFFER,a.indices,t.STATIC_DRAW)):(t.bindBuffer(t.ARRAY_BUFFER,a._vertexBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,a.vertices),t.vertexAttribPointer(l.attributes.aVertexPosition,2,t.FLOAT,!1,0,0),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,r.baseTexture._glTextures[t.id]),t.activeTexture(t.TEXTURE1),t.bindTexture(t.TEXTURE_2D,i.baseTexture._glTextures[t.id]),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,a._indexBuffer),t.bufferSubData(t.ELEMENT_ARRAY_BUFFER,0,a.indices)),t.drawElements(e.drawModes[a.drawMode],a.indices.length,t.UNSIGNED_SHORT,0),e.drawCount++}this.currentBatchSize=0},i.prototype._initWebGL=function(e){var t=this.renderer.gl;e._vertexBuffer=t.createBuffer(),e._indexBuffer=t.createBuffer(),t.bindBuffer(t.ARRAY_BUFFER,e._vertexBuffer),t.bufferData(t.ARRAY_BUFFER,e.vertices,t.DYNAMIC_DRAW),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,e._indexBuffer),t.bufferData(t.ELEMENT_ARRAY_BUFFER,e.indices,t.STATIC_DRAW)},i.prototype.destroy=function(){}},{}],13:[function(e,t,r){function i(e,t,r){r=r||{},this.renderingNormals=!1,this.renderingUnlit=!1,this._forwardRender=PIXI.WebGLRenderer.prototype.render,PIXI.WebGLRenderer.call(this,e,t,r)}i.prototype=Object.create(PIXI.WebGLRenderer.prototype),i.prototype.constructor=i,t.exports=i,Object.assign(i.prototype,{_initContext:function(){PIXI.WebGLRenderer.prototype._initContext.call(this),this.diffuseTexture=new PIXI.RenderTexture(this,this.width,this.height,null,this.resolution),this.normalsTexture=new PIXI.RenderTexture(this,this.width,this.height,null,this.resolution)},render:function(e){if(!this.gl.isContextLost()){this.drawCount=0,this._lastObjectRendered=e,this.renderingUnlit=!1,this.renderingNormals=!1,this.diffuseTexture.render(e),this.renderingNormals=!0,this.normalsTexture.render(e),this.setRenderTarget(this.renderTarget),this.setObjectRenderer(this.plugins.lights),this.plugins.lights.flush();var t=this.clearBeforeRender,r=this.drawCount;this.renderingNormals=!1,this.renderingUnlit=!0,this.clearBeforeRender=!1,this._forwardRender(e),this.clearBeforeRender=t,this.drawCount+=r}}})},{}],14:[function(e,t,r){PIXI.Circle.prototype.getMesh=function(e,t,r){e=e||40,t=t||new Float32Array(2*(e+1)),r=r||new Uint16Array(e+1);var i=2*Math.PI/e,n=-1;r[++n]=n;for(var o=0;e>=o;++o){var a=2*o,l=i*o;t[a]=Math.cos(l)*this.radius,t[a+1]=Math.sin(l)*this.radius,r[++n]=n}return r[n]=1,{vertices:t,indices:r}}},{}]},{},[1]);