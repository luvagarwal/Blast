{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","src/index","src/lightSpriteMixin.js","src/lights/WireframeShader.js","src/lights/ambientLight/AmbientLight.js","src/lights/ambientLight/AmbientLightShader.js","src/lights/directionalLight/DirectionalLight.js","src/lights/directionalLight/DirectionalLightShader.js","src/lights/light/Light.js","src/lights/light/LightShader.js","src/lights/pointLight/PointLight.js","src/lights/pointLight/PointLightShader.js","src/renderers/LightRenderer.js","src/renderers/WebGLDeferredRenderer.js","src/shapeMeshMixin.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"pixi-lights.js","sourceRoot":"./","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","module.exports = PIXI.lights = {\n//    LitSprite: require('./light_1/LitSprite'),\n//    LightingRenderer: require('./light_1/webgl/LightingRenderer')\n\n    Light:                  require('./lights/light/Light'),\n    LightShader:            require('./lights/light/LightShader'),\n\n    AmbientLight:           require('./lights/ambientLight/AmbientLight'),\n    AmbientLightShader:     require('./lights/ambientLight/AmbientLightShader'),\n\n    PointLight:             require('./lights/pointLight/PointLight'),\n    PointLightShader:       require('./lights/pointLight/PointLightShader'),\n\n    DirectionalLight:             require('./lights/directionalLight/DirectionalLight'),\n    DirectionalLightShader:       require('./lights/directionalLight/DirectionalLightShader'),\n\n    LightRenderer:          require('./renderers/LightRenderer'),\n    WebGLDeferredRenderer:  require('./renderers/WebGLDeferredRenderer'),\n\n    WireframeShader:        require('./lights/WireframeShader')\n};\n\nrequire('./lightSpriteMixin');\nrequire('./shapeMeshMixin');\n","var tempTexture = null;\n\n /**\n * Renders the object using the WebGL renderer\n *\n * @param renderer {WebGLRenderer}\n * @private\n */\nPIXI.Sprite.prototype._renderWebGL = function (renderer)\n{\n    if (!this._originalTexture) {\n        this._originalTexture = this._texture;\n    }\n\n    // unlit render pass\n    if (renderer.renderingUnlit)\n    {\n        // if it has a normal texture it is considered \"lit\", so skip it\n        if (this.normalTexture)\n        {\n            return;\n        }\n        // otherwise do a normal draw for unlit pass\n        else\n        {\n            this._texture = this._originalTexture;\n        }\n    }\n    // normals render pass\n    else if (renderer.renderingNormals)\n    {\n        // if it has no normal texture it is considered \"unlit\", so skip it\n        if (!this.normalTexture)\n        {\n            return;\n        }\n        else\n        {\n            this._texture = this.normalTexture;\n        }\n    }\n    // diffuse render pass, always just draw the texture\n    else\n    {\n        this._texture = this._originalTexture;\n    }\n\n    renderer.setObjectRenderer(renderer.plugins.sprite);\n    renderer.plugins.sprite.render(this);\n};\n","\n\n/**\n * @class\n * @extends PIXI.Shader\n * @memberof PIXI.lights\n * @param shaderManager {ShaderManager} The WebGL shader manager this shader works for.\n */\nfunction WireframeShader(shaderManager) {\n    PIXI.Shader.call(this,\n        shaderManager,\n        // vertex shader\n        [\n            'precision lowp float;',\n\n            'attribute vec2 aVertexPosition;',\n\n            'uniform mat3 projectionMatrix;',\n\n            'void main(void) {',\n            '    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);',\n            '}'\n        ].join('\\n'),\n        // fragment shader\n        [\n            'void main() {',\n            '    gl_FragColor = vec4(0, 0, 0, 1);',\n            '}'\n        ].join('\\n'),\n        // uniforms\n        {\n            translationMatrix:  { type: 'mat3', value: new Float32Array(9) },\n            projectionMatrix:   { type: 'mat3', value: new Float32Array(9) }\n        },\n        // attributes\n        {\n            aVertexPosition: 0\n        }\n    );\n}\n\nWireframeShader.prototype = Object.create(PIXI.Shader.prototype);\nWireframeShader.prototype.constructor = WireframeShader;\nmodule.exports = WireframeShader;\n\nPIXI.ShaderManager.registerPlugin('wireframeShader', WireframeShader);\n","var Light = require('../light/Light');\n\n/**\n * @class\n * @extends PIXI.lights.Light\n * @memberof PIXI.lights\n *\n * @param [color=0xFFFFFF] {number} The color of the light.\n * @param [brightness=0.5] {number} The brightness of the light.\n */\nfunction AmbientLight(color, brightness) {\n    // ambient light is drawn using a full-screen quad\n    Light.call(this, color, brightness);\n\n    this.shaderName = 'ambientLightShader';\n}\n\nAmbientLight.prototype = Object.create(Light.prototype);\nAmbientLight.prototype.constructor = AmbientLight;\nmodule.exports = AmbientLight;\n\nAmbientLight.prototype.renderWebGL = function (renderer)\n{\n    // add lights to their renderer on the normals pass\n    if (!renderer.renderingNormals) {\n        return;\n    }\n\n    // I actually don't want to interrupt the current batch, so don't set light as the current object renderer.\n    // Light renderer works a bit differently in that lights are draw individually on flush (called by WebGLDeferredRenderer).\n    //renderer.setObjectRenderer(renderer.plugins.lights);\n\n    renderer.plugins.lights.render(this);\n};\n","var LightShader = require('../light/LightShader');\n\n\n/**\n * @class\n * @extends PIXI.Shader\n * @memberof PIXI.lights\n * @param shaderManager {ShaderManager} The WebGL shader manager this shader works for.\n */\nfunction AmbientLightShader(shaderManager) {\n    LightShader.call(this,\n        shaderManager,\n        // vertex shader\n        null,\n        // fragment shader\n        \"#define GLSLIFY 1\\nprecision lowp float;\\n\\nuniform sampler2D uSampler;\\nuniform sampler2D uNormalSampler;\\n\\nuniform mat3 translationMatrix;\\n\\nuniform vec2 uViewSize;     // size of the viewport\\n\\nuniform vec4 uLightColor;   // light color, alpha channel used for intensity.\\nuniform vec3 uLightFalloff; // light attenuation coefficients (constant, linear, quadratic)\\nuniform float uLightHeight; // light height above the viewport\\n\\n\\nvoid main(void)\\n{\\nvec2 texCoord = gl_FragCoord.xy / uViewSize;\\ntexCoord.y = 1.0 - texCoord.y; // FBOs positions are flipped.\\n\\nvec4 normalColor = texture2D(uNormalSampler, texCoord);\\nnormalColor.g = 1.0 - normalColor.g; // Green layer is flipped Y coords.\\n\\n// bail out early when normal has no data\\nif (normalColor.a == 0.0) discard;\\n\\n\\n    // simplified lambert shading that makes assumptions for ambient color\\n\\n    // compute Distance\\n    float D = 1.0;\\n    \\n    // normalize vectors\\n    vec3 N = normalize(normalColor.xyz * 2.0 - 1.0);\\n    vec3 L = vec3(1.0, 1.0, 1.0);\\n    \\n    // pre-multiply light color with intensity\\n    // then perform \\\"N dot L\\\" to determine our diffuse\\n    vec3 diffuse = (uLightColor.rgb * uLightColor.a) * max(dot(N, L), 0.0);\\n\\n    vec4 diffuseColor = texture2D(uSampler, texCoord);\\n    vec3 finalColor = diffuseColor.rgb * diffuse;\\n\\n    gl_FragColor = vec4(finalColor, diffuseColor.a);\\n}\\n\"\n    );\n}\n\nAmbientLightShader.prototype = Object.create(LightShader.prototype);\nAmbientLightShader.prototype.constructor = AmbientLightShader;\nmodule.exports = AmbientLightShader;\n\nPIXI.ShaderManager.registerPlugin('ambientLightShader', AmbientLightShader);\n","var Light = require('../light/Light');\n\n/**\n * @class\n * @extends PIXI.lights.Light\n * @memberof PIXI.lights\n *\n * @param [color=0xFFFFFF] {number} The color of the light.\n * @param [brightness=1] {number} The intensity of the light.\n * @param [target] {PIXI.DisplayObject|PIXI.Point} The object in the scene to target.\n */\nfunction DirectionalLight(color, brightness, target) {\n    Light.call(this, color, brightness);\n\n    this.target = target;\n    this._directionVector = new PIXI.Point();\n\n    this._updateTransform = Light.prototype.updateTransform;\n    this._syncShader = Light.prototype.syncShader;\n\n    this.shaderName = 'directionalLightShader';\n}\n\nDirectionalLight.prototype = Object.create(Light.prototype);\nDirectionalLight.prototype.constructor = DirectionalLight;\nmodule.exports = DirectionalLight;\n\nDirectionalLight.prototype.updateTransform = function () {\n    this._updateTransform();\n\n    var vec = this._directionVector,\n        wt = this.worldTransform,\n        tx = this.target.worldTransform ? this.target.worldTransform.tx : this.target.x,\n        ty = this.target.worldTransform ? this.target.worldTransform.ty : this.target.y;\n\n    // calculate direction from this light to the target\n    vec.x = wt.tx - tx;\n    vec.y = wt.ty - ty;\n\n    // normalize\n    var len = Math.sqrt(vec.x * vec.x + vec.y * vec.y);\n    vec.x /= len;\n    vec.y /= len;\n};\n\nDirectionalLight.prototype.syncShader = function (shader) {\n    this._syncShader(shader);\n\n    shader.uniforms.uLightDirection.value[0] = this._directionVector.x;\n    shader.uniforms.uLightDirection.value[1] = this._directionVector.y;\n};\n","var LightShader = require('../light/LightShader');\n\n\n/**\n * @class\n * @extends PIXI.Shader\n * @memberof PIXI.lights\n * @param shaderManager {ShaderManager} The WebGL shader manager this shader works for.\n */\nfunction DirectionalLightShader(shaderManager) {\n    LightShader.call(this,\n        shaderManager,\n        // vertex shader\n        null,\n        // fragment shader\n        \"#define GLSLIFY 1\\nprecision lowp float;\\n\\n// imports the common uniforms like samplers, and ambient/light color\\nuniform sampler2D uSampler;\\nuniform sampler2D uNormalSampler;\\n\\nuniform mat3 translationMatrix;\\n\\nuniform vec2 uViewSize;     // size of the viewport\\n\\nuniform vec4 uLightColor;   // light color, alpha channel used for intensity.\\nuniform vec3 uLightFalloff; // light attenuation coefficients (constant, linear, quadratic)\\nuniform float uLightHeight; // light height above the viewport\\n\\n\\nuniform vec2 uLightDirection;\\n\\nvoid main()\\n{\\nvec2 texCoord = gl_FragCoord.xy / uViewSize;\\ntexCoord.y = 1.0 - texCoord.y; // FBOs positions are flipped.\\n\\nvec4 normalColor = texture2D(uNormalSampler, texCoord);\\nnormalColor.g = 1.0 - normalColor.g; // Green layer is flipped Y coords.\\n\\n// bail out early when normal has no data\\nif (normalColor.a == 0.0) discard;\\n\\n\\n    // the directional vector of the light\\n    vec3 lightVector = vec3(uLightDirection, uLightHeight);\\n\\n    // compute Distance\\n    float D = length(lightVector);\\n\\n// normalize vectors\\nvec3 N = normalize(normalColor.xyz * 2.0 - 1.0);\\nvec3 L = normalize(lightVector);\\n\\n// pre-multiply light color with intensity\\n// then perform \\\"N dot L\\\" to determine our diffuse\\nvec3 diffuse = (uLightColor.rgb * uLightColor.a) * max(dot(N, L), 0.0);\\n\\n\\n    // calculate attenuation\\n    float attenuation = 1.0;\\n\\n// calculate final intesity and color, then combine\\nvec3 intensity = diffuse * attenuation;\\nvec4 diffuseColor = texture2D(uSampler, texCoord);\\nvec3 finalColor = diffuseColor.rgb * intensity;\\n\\ngl_FragColor = vec4(finalColor, diffuseColor.a);\\n\\n}\\n\",\n        // custom uniforms\n        {\n            // the directional vector of the light\n            uLightDirection: { type: '2f', value: new Float32Array(2) }\n        }\n    );\n}\n\nDirectionalLightShader.prototype = Object.create(LightShader.prototype);\nDirectionalLightShader.prototype.constructor = DirectionalLightShader;\nmodule.exports = DirectionalLightShader;\n\nPIXI.ShaderManager.registerPlugin('directionalLightShader', DirectionalLightShader);\n","/**\n * Excuse the mess, haven't cleaned this up yet!\n */\n\n\n\n/**\n * @class\n * @extends PIXI.DisplayObject\n * @memberof PIXI.lights\n *\n * @param [color=0xFFFFFF] {number} The color of the light.\n * @param [brightness=1] {number} The brightness of the light, in range [0, 1].\n */\nfunction Light(color, brightness, vertices, indices) {\n    if (this.constructor === Light) {\n        throw new Error('Light is an abstract base class, it should not be created directly!');\n    }\n    \n    PIXI.DisplayObject.call(this);\n\n    /**\n     * An array of vertices\n     *\n     * @member {Float32Array}\n     */\n    this.vertices = vertices || new Float32Array(8);\n\n    /**\n     * An array containing the indices of the vertices\n     *\n     * @member {Uint16Array}\n     */\n    this.indices = indices || new Uint16Array([0,1,2, 0,2,3]);\n\n    /**\n     * The blend mode to be applied to the light.\n     *\n     * @member {number}\n     * @default CONST.BLEND_MODES.ADD;\n     */\n    this.blendMode = PIXI.BLEND_MODES.ADD;\n\n    /**\n     * The draw mode to be applied to the light geometry.\n     *\n     * @member {number}\n     * @default CONST.DRAW_MODES.TRIANGLES;\n     */\n    this.drawMode = PIXI.DRAW_MODES.TRIANGLES;\n\n    /**\n     * When set, the renderer will reupload the geometry data.\n     * \n     * @member {boolean}\n     */\n    this.needsUpdate = true;\n\n    /**\n     * The height of the light from the viewport.\n     *\n     * @member {number}\n     * @default 0.075\n     */\n    this.height = 0.075;\n\n    /**\n     * The falloff attenuation coeficients.\n     *\n     * @member {number[]}\n     * @default [0.75, 3, 20]\n     */\n    this.falloff = [0.75, 3, 20];\n\n    /**\n     * The name of the shader plugin to use.\n     *\n     * @member {string}\n     */\n    this.shaderName = null;\n\n    /**\n     * By default the light uses a viewport sized quad as the mesh.\n     */\n    this.useViewportQuad = true;\n\n    this.visible = false;\n\n    // webgl buffers\n    this._vertexBuffer = null;\n    this._indexBuffer = null;\n\n    // color and brightness are exposed through setters\n    this._color = 0x4d4d59;\n    this._colorRgba = [0.3, 0.3, 0.35, 0.8];\n\n    // run the color setter\n    if (color || color === 0) {\n        this.color = color;\n    }\n    \n    // run the brightness setter\n    if (brightness || brightness === 0) {\n        this.brightness = brightness;\n    }\n}\n\nLight.prototype = Object.create(PIXI.DisplayObject.prototype);\nLight.prototype.constructor = Light;\nmodule.exports = Light;\n\nObject.defineProperties(Light.prototype, {\n    /**\n     * The color of the lighting.\n     *\n     * @member {number}\n     * @memberof Light#\n     */\n    color: {\n        get: function ()\n        {\n            return this._color;\n        },\n        set: function (val)\n        {\n            this._color = val;\n            PIXI.utils.hex2rgb(val, this._colorRgba);\n        }\n    },\n\n    /**\n     * The brightness of this lighting. Normalized in the range [0, 1].\n     *\n     * @member {number}\n     * @memberof Light#\n     */\n    brightness: {\n        get: function ()\n        {\n            return this._colorRgba[3];\n        },\n        set: function (val)\n        {\n            this._colorRgba[3] = val;\n        }\n    }\n});\n\nLight.prototype.syncShader = function (shader) {\n    shader.uniforms.uUseViewportQuad.value = this.useViewportQuad;\n\n    shader.uniforms.uLightColor.value[0] = this._colorRgba[0];\n    shader.uniforms.uLightColor.value[1] = this._colorRgba[1];\n    shader.uniforms.uLightColor.value[2] = this._colorRgba[2];\n    shader.uniforms.uLightColor.value[3] = this._colorRgba[3];\n\n    shader.uniforms.uLightHeight.value = this.height;\n\n    shader.uniforms.uLightFalloff.value[0] = this.falloff[0];\n    shader.uniforms.uLightFalloff.value[1] = this.falloff[1];\n    shader.uniforms.uLightFalloff.value[2] = this.falloff[2];\n};\n\nLight.prototype.renderWebGL = function (renderer)\n{\n    // add lights to their renderer on the normals pass\n    if (!renderer.renderingNormals) {\n        return;\n    }\n\n    // I actually don't want to interrupt the current batch, so don't set light as the current object renderer.\n    // Light renderer works a bit differently in that lights are draw individually on flush (called by WebGLDeferredRenderer).\n    //renderer.setObjectRenderer(renderer.plugins.lights);\n\n    renderer.plugins.lights.render(this);\n};\n\nLight.prototype.destroy = function ()\n{\n    PIXI.DisplayObject.prototype.destroy.call(this);\n\n    // TODO: Destroy buffers!\n};\n\nLight.DRAW_MODES = {\n    \n};\n","\n\n/**\n * @class\n * @extends PIXI.Shader\n * @memberof PIXI.lights\n * @param shaderManager {ShaderManager} The WebGL shader manager this shader works for.\n */\nfunction LightShader(shaderManager, vertexSrc, fragmentSrc, customUniforms, customAttributes) {\n    var uniforms = {\n        translationMatrix:  { type: 'mat3', value: new Float32Array(9) },\n        projectionMatrix:   { type: 'mat3', value: new Float32Array(9) },\n\n        // textures from the previously rendered FBOs\n        uSampler:       { type: 'sampler2D', value: null },\n        uNormalSampler: { type: 'sampler2D', value: null },\n\n        // should we apply the translation matrix or not.\n        uUseViewportQuad: { type: 'bool', value: true },\n\n        // size of the renderer viewport\n        uViewSize:      { type: '2f', value: new Float32Array(2) },\n\n        // light color, alpha channel used for intensity.\n        uLightColor:    { type: '4f', value: new Float32Array([1, 1, 1, 1]) },\n\n        // light falloff attenuation coefficients\n        uLightFalloff:  { type: '3f', value: new Float32Array([0, 0, 0]) },\n\n        // height of the light above the viewport\n        uLightHeight: { type: '1f', value: 0.075 }\n    };\n\n    if (customUniforms)\n    {\n        for (var u in customUniforms)\n        {\n            uniforms[u] = customUniforms[u];\n        }\n    }\n\n    var attributes = {\n        aVertexPosition: 0\n    };\n\n    if (customAttributes)\n    {\n        for (var a in customAttributes)\n        {\n            attributes[a] = customAttributes[a];\n        }\n    }\n\n    PIXI.Shader.call(this, shaderManager, vertexSrc || LightShader.defaultVertexSrc, fragmentSrc, uniforms, attributes);\n}\n\nLightShader.prototype = Object.create(PIXI.Shader.prototype);\nLightShader.prototype.constructor = LightShader;\nmodule.exports = LightShader;\n\nLightShader.defaultVertexSrc = \"#define GLSLIFY 1\\nprecision lowp float;\\n\\nattribute vec2 aVertexPosition;\\n\\nuniform bool uUseViewportQuad;\\nuniform mat3 translationMatrix;\\nuniform mat3 projectionMatrix;\\n\\nvoid main(void) {\\n    if (uUseViewportQuad) {\\n        gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n    }\\n    else\\n    {\\n        gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n    }\\n}\\n\";\n","var Light = require('../light/Light');\n\n/**\n * @class\n * @extends PIXI.lights.Light\n * @memberof PIXI.lights\n *\n * @param [color=0xFFFFFF] {number} The color of the light.\n * @param [brightness=1] {number} The intensity of the light.\n * @param [radius=Infinity] {number} The distance the light reaches. You will likely need\n *  to change the falloff of the light as well if you change this value. Infinity will\n *  use the entire viewport as the drawing surface.\n */\nfunction PointLight(color, brightness, radius) {\n    radius = radius || Infinity;\n\n    if (radius !== Infinity) {\n        var shape = new PIXI.Circle(0, 0, radius),\n            mesh = shape.getMesh();\n\n        Light.call(this, color, brightness, mesh.vertices, mesh.indices);\n\n        this.useViewportQuad = false;\n        this.drawMode = PIXI.DRAW_MODES.TRIANGLE_FAN;\n    }\n    else {\n        Light.call(this, color, brightness);\n    }\n\n    this._syncShader = Light.prototype.syncShader;\n\n    this.radius = radius;\n    this.shaderName = 'pointLightShader';\n}\n\nPointLight.prototype = Object.create(Light.prototype);\nPointLight.prototype.constructor = PointLight;\nmodule.exports = PointLight;\n\nPointLight.prototype.syncShader = function (shader) {\n    this._syncShader(shader);\n\n    shader.uniforms.uLightRadius.value = this.radius;\n}\n","var LightShader = require('../light/LightShader');\n\n\n/**\n * @class\n * @extends PIXI.Shader\n * @memberof PIXI.lights\n * @param shaderManager {ShaderManager} The WebGL shader manager this shader works for.\n */\nfunction PointLightShader(shaderManager) {\n    LightShader.call(this,\n        shaderManager,\n        // vertex shader\n        null,\n        // fragment shader\n        \"#define GLSLIFY 1\\nprecision lowp float;\\n\\n// imports the common uniforms like samplers, and ambient color\\nuniform sampler2D uSampler;\\nuniform sampler2D uNormalSampler;\\n\\nuniform mat3 translationMatrix;\\n\\nuniform vec2 uViewSize;     // size of the viewport\\n\\nuniform vec4 uLightColor;   // light color, alpha channel used for intensity.\\nuniform vec3 uLightFalloff; // light attenuation coefficients (constant, linear, quadratic)\\nuniform float uLightHeight; // light height above the viewport\\n\\n\\nuniform float uLightRadius;\\n\\nvoid main()\\n{\\nvec2 texCoord = gl_FragCoord.xy / uViewSize;\\ntexCoord.y = 1.0 - texCoord.y; // FBOs positions are flipped.\\n\\nvec4 normalColor = texture2D(uNormalSampler, texCoord);\\nnormalColor.g = 1.0 - normalColor.g; // Green layer is flipped Y coords.\\n\\n// bail out early when normal has no data\\nif (normalColor.a == 0.0) discard;\\n\\n\\n    vec2 lightPosition = translationMatrix[2].xy / uViewSize;\\n\\n    // the directional vector of the light\\n    vec3 lightVector = vec3(lightPosition - texCoord, uLightHeight);\\n\\n    // correct for aspect ratio\\n    lightVector.x *= uViewSize.x / uViewSize.y;\\n\\n    // compute Distance\\n    float D = length(lightVector);\\n\\n    // bail out early when pixel outside of light sphere\\n    if (D > uLightRadius) discard;\\n\\n// normalize vectors\\nvec3 N = normalize(normalColor.xyz * 2.0 - 1.0);\\nvec3 L = normalize(lightVector);\\n\\n// pre-multiply light color with intensity\\n// then perform \\\"N dot L\\\" to determine our diffuse\\nvec3 diffuse = (uLightColor.rgb * uLightColor.a) * max(dot(N, L), 0.0);\\n\\n\\n    // calculate attenuation\\n    float attenuation = 1.0 / (uLightFalloff.x + (uLightFalloff.y * D) + (uLightFalloff.z * D * D));\\n\\n// calculate final intesity and color, then combine\\nvec3 intensity = diffuse * attenuation;\\nvec4 diffuseColor = texture2D(uSampler, texCoord);\\nvec3 finalColor = diffuseColor.rgb * intensity;\\n\\ngl_FragColor = vec4(finalColor, diffuseColor.a);\\n\\n}\",\n        // custom uniforms\n        {\n            // height of the light above the viewport\n            uLightRadius:   { type: '1f', value: 1 }\n        }\n    );\n}\n\nPointLightShader.prototype = Object.create(LightShader.prototype);\nPointLightShader.prototype.constructor = PointLightShader;\nmodule.exports = PointLightShader;\n\nPIXI.ShaderManager.registerPlugin('pointLightShader', PointLightShader);\n","/**\n *\n * @class\n * @private\n * @memberof PIXI.lights\n * @extends PIXI.ObjectRenderer\n * @param renderer {WebGLRenderer} The renderer this sprite batch works for.\n */\nfunction LightRenderer(renderer)\n{\n    PIXI.ObjectRenderer.call(this, renderer);\n\n    // the total number of indices in our batch, there are 6 points per quad.\n    var numIndices = LightRenderer.MAX_LIGHTS * 6;\n\n    /**\n     * Holds the indices\n     *\n     * @member {Uint16Array}\n     */\n    this.indices = new Uint16Array(numIndices);\n\n    //TODO this could be a single buffer shared amongst all renderers as we reuse this set up in most renderers\n    for (var i = 0, j = 0; i < numIndices; i += 6, j += 4)\n    {\n        this.indices[i + 0] = j + 0;\n        this.indices[i + 1] = j + 1;\n        this.indices[i + 2] = j + 2;\n        this.indices[i + 3] = j + 0;\n        this.indices[i + 4] = j + 2;\n        this.indices[i + 5] = j + 3;\n    }\n\n    /**\n     * The current size of the batch, each render() call adds to this number.\n     *\n     * @member {number}\n     */\n    this.currentBatchSize = 0;\n\n    /**\n     * The current lights in the batch.\n     *\n     * @member {Light[]}\n     */\n    this.lights = [];\n}\n\nLightRenderer.MAX_LIGHTS = 500;\n\nLightRenderer.prototype = Object.create(PIXI.ObjectRenderer.prototype);\nLightRenderer.prototype.constructor = LightRenderer;\nmodule.exports = LightRenderer;\n\nPIXI.WebGLRenderer.registerPlugin('lights', LightRenderer);\n\n/**\n * Renders the light object.\n *\n * @param light {Light} the light to render\n */\nLightRenderer.prototype.render = function (light)\n{\n    this.lights[this.currentBatchSize++] = light;\n};\n\nLightRenderer.prototype.flush = function ()\n{\n    var renderer = this.renderer,\n        gl = renderer.gl,\n        diffuseTexture = renderer.diffuseTexture,\n        normalsTexture = renderer.normalsTexture,\n        lastShader = null;\n\n    for (var i = 0; i < this.currentBatchSize; ++i)\n    {\n        var light = this.lights[i],\n            shader = light.shader || this.renderer.shaderManager.plugins[light.shaderName];\n\n        if (!light._vertexBuffer)\n        {\n            this._initWebGL(light);\n        }\n\n        // set shader if needed\n        if (shader !== lastShader) {\n            lastShader = shader;\n            renderer.shaderManager.setShader(shader);\n        }\n\n        renderer.blendModeManager.setBlendMode(light.blendMode);\n\n        // set uniforms, can do some optimizations here.\n        shader.uniforms.uViewSize.value[0] = renderer.width;\n        shader.uniforms.uViewSize.value[1] = renderer.height;\n\n        light.worldTransform.toArray(true, shader.uniforms.translationMatrix.value);\n        renderer.currentRenderTarget.projectionMatrix.toArray(true, shader.uniforms.projectionMatrix.value);\n\n        if (light.useViewportQuad) {\n            // update verts to ensure it is a fullscreen quad even if the renderer is resized. This should be optimized\n            light.vertices[2] = light.vertices[4] = renderer.width;\n            light.vertices[5] = light.vertices[7] = renderer.height;\n        }\n\n        light.syncShader(shader);\n\n        shader.syncUniforms();\n\n        // have to set these manually due to the way pixi base shader makes assumptions about texture units\n        gl.uniform1i(shader.uniforms.uSampler._location, 0);\n        gl.uniform1i(shader.uniforms.uNormalSampler._location, 1);\n\n        if (!light.needsUpdate)\n        {\n            // update vertex data\n            gl.bindBuffer(gl.ARRAY_BUFFER, light._vertexBuffer);\n            gl.bufferSubData(gl.ARRAY_BUFFER, 0, light.vertices);\n            gl.vertexAttribPointer(shader.attributes.aVertexPosition, 2, gl.FLOAT, false, 0, 0);\n\n            // bind diffuse texture\n            gl.activeTexture(gl.TEXTURE0);\n            gl.bindTexture(gl.TEXTURE_2D, diffuseTexture.baseTexture._glTextures[gl.id]);\n\n            // bind normal texture\n            gl.activeTexture(gl.TEXTURE1);\n            gl.bindTexture(gl.TEXTURE_2D, normalsTexture.baseTexture._glTextures[gl.id]);\n\n            // update indices\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, light._indexBuffer);\n            gl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER, 0, light.indices);\n        }\n        else\n        {\n            light.needsUpdate = false;\n\n            // upload vertex data\n            gl.bindBuffer(gl.ARRAY_BUFFER, light._vertexBuffer);\n            gl.bufferData(gl.ARRAY_BUFFER, light.vertices, gl.STATIC_DRAW);\n            gl.vertexAttribPointer(shader.attributes.aVertexPosition, 2, gl.FLOAT, false, 0, 0);\n\n            // bind diffuse texture\n            gl.activeTexture(gl.TEXTURE0);\n            gl.bindTexture(gl.TEXTURE_2D, diffuseTexture.baseTexture._glTextures[gl.id]);\n\n            // bind normal texture\n            gl.activeTexture(gl.TEXTURE1);\n            gl.bindTexture(gl.TEXTURE_2D, normalsTexture.baseTexture._glTextures[gl.id]);\n\n            // static upload of index buffer\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, light._indexBuffer);\n            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, light.indices, gl.STATIC_DRAW);\n        }\n\n        gl.drawElements(renderer.drawModes[light.drawMode], light.indices.length, gl.UNSIGNED_SHORT, 0);\n        renderer.drawCount++;\n    }\n\n    this.currentBatchSize = 0;\n};\n\n/**\n * Prepares all the buffers to render this light.\n *\n * @param light {Light} The light object to prepare for rendering.\n */\nLightRenderer.prototype._initWebGL = function (light)\n{\n    var gl = this.renderer.gl;\n\n    // create the buffers\n    light._vertexBuffer = gl.createBuffer();\n    light._indexBuffer = gl.createBuffer();\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, light._vertexBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, light.vertices, gl.DYNAMIC_DRAW);\n\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, light._indexBuffer);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, light.indices, gl.STATIC_DRAW);\n};\n\nLightRenderer.prototype.destroy = function ()\n{\n    \n};\n","/**\n * The WebGLDeferredRenderer draws the scene and all its content onto a webGL enabled canvas. This renderer\n * should be used for browsers that support webGL. This Render works by automatically managing webGLBatchs.\n * So no need for Sprite Batches or Sprite Clouds.\n * Don't forget to add the view to your DOM or you will not see anything :)\n *\n * @class\n * @memberof PIXI.lights\n * @extends PIXI.SystemRenderer\n * @param [width=0] {number} the width of the canvas view\n * @param [height=0] {number} the height of the canvas view\n * @param [options] {object} The optional renderer parameters\n * @param [options.view] {HTMLCanvasElement} the canvas to use as a view, optional\n * @param [options.transparent=false] {boolean} If the render view is transparent, default false\n * @param [options.autoResize=false] {boolean} If the render view is automatically resized, default false\n * @param [options.antialias=false] {boolean} sets antialias. If not available natively then FXAA antialiasing is used\n * @param [options.forceFXAA=false] {boolean} forces FXAA antialiasing to be used over native. FXAA is faster, but may not always lok as great\n * @param [options.resolution=1] {number} the resolution of the renderer retina would be 2\n * @param [options.clearBeforeRender=true] {boolean} This sets if the CanvasRenderer will clear the canvas or\n *      not before the new render pass.\n * @param [options.preserveDrawingBuffer=false] {boolean} enables drawing buffer preservation, enable this if\n *      you need to call toDataUrl on the webgl context.\n */\nfunction WebGLDeferredRenderer(width, height, options)\n{\n    options = options || {};\n\n    this.renderingNormals = false;\n    this.renderingUnlit = false;\n    this._forwardRender = PIXI.WebGLRenderer.prototype.render;\n\n    PIXI.WebGLRenderer.call(this, width, height, options);\n}\n\nWebGLDeferredRenderer.prototype = Object.create(PIXI.WebGLRenderer.prototype);\nWebGLDeferredRenderer.prototype.constructor = WebGLDeferredRenderer;\nmodule.exports = WebGLDeferredRenderer;\n\n/** @lends PIXI.DisplayObject# */\nObject.assign(WebGLDeferredRenderer.prototype, {\n    /**\n     * Initializes the context and necessary framebuffers.\n     */\n    _initContext: function ()\n    {\n        // call parent init\n        PIXI.WebGLRenderer.prototype._initContext.call(this);\n\n        // first create our render targets.\n        this.diffuseTexture = new PIXI.RenderTexture(this, this.width, this.height, null, this.resolution);\n        this.normalsTexture = new PIXI.RenderTexture(this, this.width, this.height, null, this.resolution);\n    },\n\n    // TODO Optimizations:\n    // Only call `updateTransform` once, right now it is call each render pass.\n    // Optimize render texture rendering to reduce duplication, or use render targets directly.\n    // Cache tree transversal, cache elements to use for each render pass?\n\n    render: function (object)\n    {\n        // no point rendering if our context has been blown up!\n        if (this.gl.isContextLost())\n        {\n            return;\n        }\n\n        this.drawCount = 0;\n\n        this._lastObjectRendered = object;\n\n        /////////////\n        //  Rendering\n        this.renderingUnlit = false;\n\n        // render diffuse\n        this.renderingNormals = false;\n        this.diffuseTexture.render(object);\n\n        // render normals\n        this.renderingNormals = true;\n        this.normalsTexture.render(object);\n\n        // render lights\n        this.setRenderTarget(this.renderTarget);\n        this.setObjectRenderer(this.plugins.lights);\n        this.plugins.lights.flush();\n\n        // forward render unlit objects (no normal texture)\n        var cbr = this.clearBeforeRender,\n            draws = this.drawCount;\n\n        this.renderingNormals = false;\n        this.renderingUnlit = true;\n        this.clearBeforeRender = false;\n\n        this._forwardRender(object);\n        this.clearBeforeRender = cbr;\n        this.drawCount += draws;\n        /////////////\n    }\n});\n","/**\n * Creates vertices and indices arrays to describe this circle.\n * \n * @param [totalSegments=40] {number} Total segments to build for the circle mesh.\n * @param [verticesOutput] {Float32Array} An array to output the vertices into. Length must be\n *  `((totalSegments + 2) * 2)` or more. If not passed it is created for you.\n * @param [indicesOutput] {Uint16Array} An array to output the indices into, in gl.TRIANGLE_FAN format. Length must\n *  be `(totalSegments + 3)` or more. If not passed it is created for you.\n */\nPIXI.Circle.prototype.getMesh = function (totalSegments, vertices, indices)\n{\n    totalSegments = totalSegments || 40;\n\n    vertices = vertices || new Float32Array((totalSegments + 1) * 2);\n    indices = indices || new Uint16Array(totalSegments + 1);\n\n    var seg = (Math.PI * 2) / totalSegments,\n        indicesIndex = -1;\n\n    indices[++indicesIndex] = indicesIndex;\n\n    for (var i = 0; i <= totalSegments; ++i)\n    {\n        var index = i*2;\n        var angle = seg * i;\n\n        vertices[index] = Math.cos(angle) * this.radius;\n        vertices[index+1] = Math.sin(angle) * this.radius;\n\n        indices[++indicesIndex] = indicesIndex;\n    }\n\n    indices[indicesIndex] = 1;\n\n    return {\n        vertices: vertices,\n        indices: indices\n    };\n};\n"]}