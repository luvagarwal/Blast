{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","src/index","pixi-lights.min.js","src/lightSpriteMixin.js","src/lights/WireframeShader.js","src/lights/ambientLight/AmbientLight.js","src/lights/ambientLight/AmbientLightShader.js","src/lights/directionalLight/DirectionalLight.js","src/lights/directionalLight/DirectionalLightShader.js","src/lights/light/Light.js","src/lights/light/LightShader.js","src/lights/pointLight/PointLight.js","src/lights/pointLight/PointLightShader.js","src/renderers/LightRenderer.js","src/renderers/WebGLDeferredRenderer.js","src/shapeMeshMixin.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","PIXI","lights","Light","LightShader","AmbientLight","AmbientLightShader","PointLight","PointLightShader","DirectionalLight","DirectionalLightShader","LightRenderer","WebGLDeferredRenderer","WireframeShader","./lightSpriteMixin","./lights/WireframeShader","./lights/ambientLight/AmbientLight","./lights/ambientLight/AmbientLightShader","./lights/directionalLight/DirectionalLight","./lights/directionalLight/DirectionalLightShader","./lights/light/Light","./lights/light/LightShader","./lights/pointLight/PointLight","./lights/pointLight/PointLightShader","./renderers/LightRenderer","./renderers/WebGLDeferredRenderer","./shapeMeshMixin",2,"Sprite","prototype","_renderWebGL","renderer","this","_originalTexture","_texture","renderingUnlit","normalTexture","renderingNormals","setObjectRenderer","plugins","sprite","render",3,"shaderManager","Shader","join","translationMatrix","type","value","Float32Array","projectionMatrix","aVertexPosition","Object","create","constructor","ShaderManager","registerPlugin",4,"color","brightness","shaderName","renderWebGL","../light/Light",5,"../light/LightShader",6,"target","_directionVector","Point","_updateTransform","updateTransform","_syncShader","syncShader","vec","wt","worldTransform","tx","x","ty","y","len","Math","sqrt","shader","uniforms","uLightDirection",7,8,"vertices","indices","DisplayObject","Uint16Array","blendMode","BLEND_MODES","ADD","drawMode","DRAW_MODES","TRIANGLES","needsUpdate","height","falloff","useViewportQuad","visible","_vertexBuffer","_indexBuffer","_color","_colorRgba","defineProperties","get","set","val","utils","hex2rgb","uUseViewportQuad","uLightColor","uLightHeight","uLightFalloff","destroy",9,"vertexSrc","fragmentSrc","customUniforms","customAttributes","uSampler","uNormalSampler","uViewSize","attributes","defaultVertexSrc",10,"radius","Infinity","shape","Circle","mesh","getMesh","TRIANGLE_FAN","uLightRadius",11,12,"ObjectRenderer","numIndices","MAX_LIGHTS","j","currentBatchSize","WebGLRenderer","light","flush","gl","diffuseTexture","normalsTexture","lastShader","_initWebGL","setShader","blendModeManager","setBlendMode","width","toArray","currentRenderTarget","syncUniforms","uniform1i","_location","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","vertexAttribPointer","FLOAT","activeTexture","TEXTURE0","bindTexture","TEXTURE_2D","baseTexture","_glTextures","id","TEXTURE1","ELEMENT_ARRAY_BUFFER","bufferSubData","drawElements","drawModes","UNSIGNED_SHORT","drawCount","createBuffer","DYNAMIC_DRAW",13,"options","_forwardRender","assign","_initContext","RenderTexture","resolution","object","isContextLost","_lastObjectRendered","setRenderTarget","renderTarget","cbr","clearBeforeRender","draws",14,"totalSegments","seg","PI","indicesIndex","index","angle","cos","sin"],"mappings":"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","file":"pixi-lights.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","module.exports = PIXI.lights = {\n//    LitSprite: require('./light_1/LitSprite'),\n//    LightingRenderer: require('./light_1/webgl/LightingRenderer')\n\n    Light:                  require('./lights/light/Light'),\n    LightShader:            require('./lights/light/LightShader'),\n\n    AmbientLight:           require('./lights/ambientLight/AmbientLight'),\n    AmbientLightShader:     require('./lights/ambientLight/AmbientLightShader'),\n\n    PointLight:             require('./lights/pointLight/PointLight'),\n    PointLightShader:       require('./lights/pointLight/PointLightShader'),\n\n    DirectionalLight:             require('./lights/directionalLight/DirectionalLight'),\n    DirectionalLightShader:       require('./lights/directionalLight/DirectionalLightShader'),\n\n    LightRenderer:          require('./renderers/LightRenderer'),\n    WebGLDeferredRenderer:  require('./renderers/WebGLDeferredRenderer'),\n\n    WireframeShader:        require('./lights/WireframeShader')\n};\n\nrequire('./lightSpriteMixin');\nrequire('./shapeMeshMixin');\n",null,"var tempTexture = null;\n\n /**\n * Renders the object using the WebGL renderer\n *\n * @param renderer {WebGLRenderer}\n * @private\n */\nPIXI.Sprite.prototype._renderWebGL = function (renderer)\n{\n    if (!this._originalTexture) {\n        this._originalTexture = this._texture;\n    }\n\n    // unlit render pass\n    if (renderer.renderingUnlit)\n    {\n        // if it has a normal texture it is considered \"lit\", so skip it\n        if (this.normalTexture)\n        {\n            return;\n        }\n        // otherwise do a normal draw for unlit pass\n        else\n        {\n            this._texture = this._originalTexture;\n        }\n    }\n    // normals render pass\n    else if (renderer.renderingNormals)\n    {\n        // if it has no normal texture it is considered \"unlit\", so skip it\n        if (!this.normalTexture)\n        {\n            return;\n        }\n        else\n        {\n            this._texture = this.normalTexture;\n        }\n    }\n    // diffuse render pass, always just draw the texture\n    else\n    {\n        this._texture = this._originalTexture;\n    }\n\n    renderer.setObjectRenderer(renderer.plugins.sprite);\n    renderer.plugins.sprite.render(this);\n};\n","\n\n/**\n * @class\n * @extends PIXI.Shader\n * @memberof PIXI.lights\n * @param shaderManager {ShaderManager} The WebGL shader manager this shader works for.\n */\nfunction WireframeShader(shaderManager) {\n    PIXI.Shader.call(this,\n        shaderManager,\n        // vertex shader\n        [\n            'precision lowp float;',\n\n            'attribute vec2 aVertexPosition;',\n\n            'uniform mat3 projectionMatrix;',\n\n            'void main(void) {',\n            '    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);',\n            '}'\n        ].join('\\n'),\n        // fragment shader\n        [\n            'void main() {',\n            '    gl_FragColor = vec4(0, 0, 0, 1);',\n            '}'\n        ].join('\\n'),\n        // uniforms\n        {\n            translationMatrix:  { type: 'mat3', value: new Float32Array(9) },\n            projectionMatrix:   { type: 'mat3', value: new Float32Array(9) }\n        },\n        // attributes\n        {\n            aVertexPosition: 0\n        }\n    );\n}\n\nWireframeShader.prototype = Object.create(PIXI.Shader.prototype);\nWireframeShader.prototype.constructor = WireframeShader;\nmodule.exports = WireframeShader;\n\nPIXI.ShaderManager.registerPlugin('wireframeShader', WireframeShader);\n","var Light = require('../light/Light');\n\n/**\n * @class\n * @extends PIXI.lights.Light\n * @memberof PIXI.lights\n *\n * @param [color=0xFFFFFF] {number} The color of the light.\n * @param [brightness=0.5] {number} The brightness of the light.\n */\nfunction AmbientLight(color, brightness) {\n    // ambient light is drawn using a full-screen quad\n    Light.call(this, color, brightness);\n\n    this.shaderName = 'ambientLightShader';\n}\n\nAmbientLight.prototype = Object.create(Light.prototype);\nAmbientLight.prototype.constructor = AmbientLight;\nmodule.exports = AmbientLight;\n\nAmbientLight.prototype.renderWebGL = function (renderer)\n{\n    // add lights to their renderer on the normals pass\n    if (!renderer.renderingNormals) {\n        return;\n    }\n\n    // I actually don't want to interrupt the current batch, so don't set light as the current object renderer.\n    // Light renderer works a bit differently in that lights are draw individually on flush (called by WebGLDeferredRenderer).\n    //renderer.setObjectRenderer(renderer.plugins.lights);\n\n    renderer.plugins.lights.render(this);\n};\n","var LightShader = require('../light/LightShader');\n\n\n/**\n * @class\n * @extends PIXI.Shader\n * @memberof PIXI.lights\n * @param shaderManager {ShaderManager} The WebGL shader manager this shader works for.\n */\nfunction AmbientLightShader(shaderManager) {\n    LightShader.call(this,\n        shaderManager,\n        // vertex shader\n        null,\n        // fragment shader\n        \"#define GLSLIFY 1\\nprecision lowp float;\\n\\nuniform sampler2D uSampler;\\nuniform sampler2D uNormalSampler;\\n\\nuniform mat3 translationMatrix;\\n\\nuniform vec2 uViewSize;     // size of the viewport\\n\\nuniform vec4 uLightColor;   // light color, alpha channel used for intensity.\\nuniform vec3 uLightFalloff; // light attenuation coefficients (constant, linear, quadratic)\\nuniform float uLightHeight; // light height above the viewport\\n\\n\\nvoid main(void)\\n{\\nvec2 texCoord = gl_FragCoord.xy / uViewSize;\\ntexCoord.y = 1.0 - texCoord.y; // FBOs positions are flipped.\\n\\nvec4 normalColor = texture2D(uNormalSampler, texCoord);\\nnormalColor.g = 1.0 - normalColor.g; // Green layer is flipped Y coords.\\n\\n// bail out early when normal has no data\\nif (normalColor.a == 0.0) discard;\\n\\n\\n    // simplified lambert shading that makes assumptions for ambient color\\n\\n    // compute Distance\\n    float D = 1.0;\\n    \\n    // normalize vectors\\n    vec3 N = normalize(normalColor.xyz * 2.0 - 1.0);\\n    vec3 L = vec3(1.0, 1.0, 1.0);\\n    \\n    // pre-multiply light color with intensity\\n    // then perform \\\"N dot L\\\" to determine our diffuse\\n    vec3 diffuse = (uLightColor.rgb * uLightColor.a) * max(dot(N, L), 0.0);\\n\\n    vec4 diffuseColor = texture2D(uSampler, texCoord);\\n    vec3 finalColor = diffuseColor.rgb * diffuse;\\n\\n    gl_FragColor = vec4(finalColor, diffuseColor.a);\\n}\\n\"\n    );\n}\n\nAmbientLightShader.prototype = Object.create(LightShader.prototype);\nAmbientLightShader.prototype.constructor = AmbientLightShader;\nmodule.exports = AmbientLightShader;\n\nPIXI.ShaderManager.registerPlugin('ambientLightShader', AmbientLightShader);\n","var Light = require('../light/Light');\n\n/**\n * @class\n * @extends PIXI.lights.Light\n * @memberof PIXI.lights\n *\n * @param [color=0xFFFFFF] {number} The color of the light.\n * @param [brightness=1] {number} The intensity of the light.\n * @param [target] {PIXI.DisplayObject|PIXI.Point} The object in the scene to target.\n */\nfunction DirectionalLight(color, brightness, target) {\n    Light.call(this, color, brightness);\n\n    this.target = target;\n    this._directionVector = new PIXI.Point();\n\n    this._updateTransform = Light.prototype.updateTransform;\n    this._syncShader = Light.prototype.syncShader;\n\n    this.shaderName = 'directionalLightShader';\n}\n\nDirectionalLight.prototype = Object.create(Light.prototype);\nDirectionalLight.prototype.constructor = DirectionalLight;\nmodule.exports = DirectionalLight;\n\nDirectionalLight.prototype.updateTransform = function () {\n    this._updateTransform();\n\n    var vec = this._directionVector,\n        wt = this.worldTransform,\n        tx = this.target.worldTransform ? this.target.worldTransform.tx : this.target.x,\n        ty = this.target.worldTransform ? this.target.worldTransform.ty : this.target.y;\n\n    // calculate direction from this light to the target\n    vec.x = wt.tx - tx;\n    vec.y = wt.ty - ty;\n\n    // normalize\n    var len = Math.sqrt(vec.x * vec.x + vec.y * vec.y);\n    vec.x /= len;\n    vec.y /= len;\n};\n\nDirectionalLight.prototype.syncShader = function (shader) {\n    this._syncShader(shader);\n\n    shader.uniforms.uLightDirection.value[0] = this._directionVector.x;\n    shader.uniforms.uLightDirection.value[1] = this._directionVector.y;\n};\n","var LightShader = require('../light/LightShader');\n\n\n/**\n * @class\n * @extends PIXI.Shader\n * @memberof PIXI.lights\n * @param shaderManager {ShaderManager} The WebGL shader manager this shader works for.\n */\nfunction DirectionalLightShader(shaderManager) {\n    LightShader.call(this,\n        shaderManager,\n        // vertex shader\n        null,\n        // fragment shader\n        \"#define GLSLIFY 1\\nprecision lowp float;\\n\\n// imports the common uniforms like samplers, and ambient/light color\\nuniform sampler2D uSampler;\\nuniform sampler2D uNormalSampler;\\n\\nuniform mat3 translationMatrix;\\n\\nuniform vec2 uViewSize;     // size of the viewport\\n\\nuniform vec4 uLightColor;   // light color, alpha channel used for intensity.\\nuniform vec3 uLightFalloff; // light attenuation coefficients (constant, linear, quadratic)\\nuniform float uLightHeight; // light height above the viewport\\n\\n\\nuniform vec2 uLightDirection;\\n\\nvoid main()\\n{\\nvec2 texCoord = gl_FragCoord.xy / uViewSize;\\ntexCoord.y = 1.0 - texCoord.y; // FBOs positions are flipped.\\n\\nvec4 normalColor = texture2D(uNormalSampler, texCoord);\\nnormalColor.g = 1.0 - normalColor.g; // Green layer is flipped Y coords.\\n\\n// bail out early when normal has no data\\nif (normalColor.a == 0.0) discard;\\n\\n\\n    // the directional vector of the light\\n    vec3 lightVector = vec3(uLightDirection, uLightHeight);\\n\\n    // compute Distance\\n    float D = length(lightVector);\\n\\n// normalize vectors\\nvec3 N = normalize(normalColor.xyz * 2.0 - 1.0);\\nvec3 L = normalize(lightVector);\\n\\n// pre-multiply light color with intensity\\n// then perform \\\"N dot L\\\" to determine our diffuse\\nvec3 diffuse = (uLightColor.rgb * uLightColor.a) * max(dot(N, L), 0.0);\\n\\n\\n    // calculate attenuation\\n    float attenuation = 1.0;\\n\\n// calculate final intesity and color, then combine\\nvec3 intensity = diffuse * attenuation;\\nvec4 diffuseColor = texture2D(uSampler, texCoord);\\nvec3 finalColor = diffuseColor.rgb * intensity;\\n\\ngl_FragColor = vec4(finalColor, diffuseColor.a);\\n\\n}\\n\",\n        // custom uniforms\n        {\n            // the directional vector of the light\n            uLightDirection: { type: '2f', value: new Float32Array(2) }\n        }\n    );\n}\n\nDirectionalLightShader.prototype = Object.create(LightShader.prototype);\nDirectionalLightShader.prototype.constructor = DirectionalLightShader;\nmodule.exports = DirectionalLightShader;\n\nPIXI.ShaderManager.registerPlugin('directionalLightShader', DirectionalLightShader);\n","/**\n * Excuse the mess, haven't cleaned this up yet!\n */\n\n\n\n/**\n * @class\n * @extends PIXI.DisplayObject\n * @memberof PIXI.lights\n *\n * @param [color=0xFFFFFF] {number} The color of the light.\n * @param [brightness=1] {number} The brightness of the light, in range [0, 1].\n */\nfunction Light(color, brightness, vertices, indices) {\n    if (this.constructor === Light) {\n        throw new Error('Light is an abstract base class, it should not be created directly!');\n    }\n    \n    PIXI.DisplayObject.call(this);\n\n    /**\n     * An array of vertices\n     *\n     * @member {Float32Array}\n     */\n    this.vertices = vertices || new Float32Array(8);\n\n    /**\n     * An array containing the indices of the vertices\n     *\n     * @member {Uint16Array}\n     */\n    this.indices = indices || new Uint16Array([0,1,2, 0,2,3]);\n\n    /**\n     * The blend mode to be applied to the light.\n     *\n     * @member {number}\n     * @default CONST.BLEND_MODES.ADD;\n     */\n    this.blendMode = PIXI.BLEND_MODES.ADD;\n\n    /**\n     * The draw mode to be applied to the light geometry.\n     *\n     * @member {number}\n     * @default CONST.DRAW_MODES.TRIANGLES;\n     */\n    this.drawMode = PIXI.DRAW_MODES.TRIANGLES;\n\n    /**\n     * When set, the renderer will reupload the geometry data.\n     * \n     * @member {boolean}\n     */\n    this.needsUpdate = true;\n\n    /**\n     * The height of the light from the viewport.\n     *\n     * @member {number}\n     * @default 0.075\n     */\n    this.height = 0.075;\n\n    /**\n     * The falloff attenuation coeficients.\n     *\n     * @member {number[]}\n     * @default [0.75, 3, 20]\n     */\n    this.falloff = [0.75, 3, 20];\n\n    /**\n     * The name of the shader plugin to use.\n     *\n     * @member {string}\n     */\n    this.shaderName = null;\n\n    /**\n     * By default the light uses a viewport sized quad as the mesh.\n     */\n    this.useViewportQuad = true;\n\n    this.visible = false;\n\n    // webgl buffers\n    this._vertexBuffer = null;\n    this._indexBuffer = null;\n\n    // color and brightness are exposed through setters\n    this._color = 0x4d4d59;\n    this._colorRgba = [0.3, 0.3, 0.35, 0.8];\n\n    // run the color setter\n    if (color || color === 0) {\n        this.color = color;\n    }\n    \n    // run the brightness setter\n    if (brightness || brightness === 0) {\n        this.brightness = brightness;\n    }\n}\n\nLight.prototype = Object.create(PIXI.DisplayObject.prototype);\nLight.prototype.constructor = Light;\nmodule.exports = Light;\n\nObject.defineProperties(Light.prototype, {\n    /**\n     * The color of the lighting.\n     *\n     * @member {number}\n     * @memberof Light#\n     */\n    color: {\n        get: function ()\n        {\n            return this._color;\n        },\n        set: function (val)\n        {\n            this._color = val;\n            PIXI.utils.hex2rgb(val, this._colorRgba);\n        }\n    },\n\n    /**\n     * The brightness of this lighting. Normalized in the range [0, 1].\n     *\n     * @member {number}\n     * @memberof Light#\n     */\n    brightness: {\n        get: function ()\n        {\n            return this._colorRgba[3];\n        },\n        set: function (val)\n        {\n            this._colorRgba[3] = val;\n        }\n    }\n});\n\nLight.prototype.syncShader = function (shader) {\n    shader.uniforms.uUseViewportQuad.value = this.useViewportQuad;\n\n    shader.uniforms.uLightColor.value[0] = this._colorRgba[0];\n    shader.uniforms.uLightColor.value[1] = this._colorRgba[1];\n    shader.uniforms.uLightColor.value[2] = this._colorRgba[2];\n    shader.uniforms.uLightColor.value[3] = this._colorRgba[3];\n\n    shader.uniforms.uLightHeight.value = this.height;\n\n    shader.uniforms.uLightFalloff.value[0] = this.falloff[0];\n    shader.uniforms.uLightFalloff.value[1] = this.falloff[1];\n    shader.uniforms.uLightFalloff.value[2] = this.falloff[2];\n};\n\nLight.prototype.renderWebGL = function (renderer)\n{\n    // add lights to their renderer on the normals pass\n    if (!renderer.renderingNormals) {\n        return;\n    }\n\n    // I actually don't want to interrupt the current batch, so don't set light as the current object renderer.\n    // Light renderer works a bit differently in that lights are draw individually on flush (called by WebGLDeferredRenderer).\n    //renderer.setObjectRenderer(renderer.plugins.lights);\n\n    renderer.plugins.lights.render(this);\n};\n\nLight.prototype.destroy = function ()\n{\n    PIXI.DisplayObject.prototype.destroy.call(this);\n\n    // TODO: Destroy buffers!\n};\n\nLight.DRAW_MODES = {\n    \n};\n","\n\n/**\n * @class\n * @extends PIXI.Shader\n * @memberof PIXI.lights\n * @param shaderManager {ShaderManager} The WebGL shader manager this shader works for.\n */\nfunction LightShader(shaderManager, vertexSrc, fragmentSrc, customUniforms, customAttributes) {\n    var uniforms = {\n        translationMatrix:  { type: 'mat3', value: new Float32Array(9) },\n        projectionMatrix:   { type: 'mat3', value: new Float32Array(9) },\n\n        // textures from the previously rendered FBOs\n        uSampler:       { type: 'sampler2D', value: null },\n        uNormalSampler: { type: 'sampler2D', value: null },\n\n        // should we apply the translation matrix or not.\n        uUseViewportQuad: { type: 'bool', value: true },\n\n        // size of the renderer viewport\n        uViewSize:      { type: '2f', value: new Float32Array(2) },\n\n        // light color, alpha channel used for intensity.\n        uLightColor:    { type: '4f', value: new Float32Array([1, 1, 1, 1]) },\n\n        // light falloff attenuation coefficients\n        uLightFalloff:  { type: '3f', value: new Float32Array([0, 0, 0]) },\n\n        // height of the light above the viewport\n        uLightHeight: { type: '1f', value: 0.075 }\n    };\n\n    if (customUniforms)\n    {\n        for (var u in customUniforms)\n        {\n            uniforms[u] = customUniforms[u];\n        }\n    }\n\n    var attributes = {\n        aVertexPosition: 0\n    };\n\n    if (customAttributes)\n    {\n        for (var a in customAttributes)\n        {\n            attributes[a] = customAttributes[a];\n        }\n    }\n\n    PIXI.Shader.call(this, shaderManager, vertexSrc || LightShader.defaultVertexSrc, fragmentSrc, uniforms, attributes);\n}\n\nLightShader.prototype = Object.create(PIXI.Shader.prototype);\nLightShader.prototype.constructor = LightShader;\nmodule.exports = LightShader;\n\nLightShader.defaultVertexSrc = \"#define GLSLIFY 1\\nprecision lowp float;\\n\\nattribute vec2 aVertexPosition;\\n\\nuniform bool uUseViewportQuad;\\nuniform mat3 translationMatrix;\\nuniform mat3 projectionMatrix;\\n\\nvoid main(void) {\\n    if (uUseViewportQuad) {\\n        gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n    }\\n    else\\n    {\\n        gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n    }\\n}\\n\";\n","var Light = require('../light/Light');\n\n/**\n * @class\n * @extends PIXI.lights.Light\n * @memberof PIXI.lights\n *\n * @param [color=0xFFFFFF] {number} The color of the light.\n * @param [brightness=1] {number} The intensity of the light.\n * @param [radius=Infinity] {number} The distance the light reaches. You will likely need\n *  to change the falloff of the light as well if you change this value. Infinity will\n *  use the entire viewport as the drawing surface.\n */\nfunction PointLight(color, brightness, radius) {\n    radius = radius || Infinity;\n\n    if (radius !== Infinity) {\n        var shape = new PIXI.Circle(0, 0, radius),\n            mesh = shape.getMesh();\n\n        Light.call(this, color, brightness, mesh.vertices, mesh.indices);\n\n        this.useViewportQuad = false;\n        this.drawMode = PIXI.DRAW_MODES.TRIANGLE_FAN;\n    }\n    else {\n        Light.call(this, color, brightness);\n    }\n\n    this._syncShader = Light.prototype.syncShader;\n\n    this.radius = radius;\n    this.shaderName = 'pointLightShader';\n}\n\nPointLight.prototype = Object.create(Light.prototype);\nPointLight.prototype.constructor = PointLight;\nmodule.exports = PointLight;\n\nPointLight.prototype.syncShader = function (shader) {\n    this._syncShader(shader);\n\n    shader.uniforms.uLightRadius.value = this.radius;\n}\n","var LightShader = require('../light/LightShader');\n\n\n/**\n * @class\n * @extends PIXI.Shader\n * @memberof PIXI.lights\n * @param shaderManager {ShaderManager} The WebGL shader manager this shader works for.\n */\nfunction PointLightShader(shaderManager) {\n    LightShader.call(this,\n        shaderManager,\n        // vertex shader\n        null,\n        // fragment shader\n        \"#define GLSLIFY 1\\nprecision lowp float;\\n\\n// imports the common uniforms like samplers, and ambient color\\nuniform sampler2D uSampler;\\nuniform sampler2D uNormalSampler;\\n\\nuniform mat3 translationMatrix;\\n\\nuniform vec2 uViewSize;     // size of the viewport\\n\\nuniform vec4 uLightColor;   // light color, alpha channel used for intensity.\\nuniform vec3 uLightFalloff; // light attenuation coefficients (constant, linear, quadratic)\\nuniform float uLightHeight; // light height above the viewport\\n\\n\\nuniform float uLightRadius;\\n\\nvoid main()\\n{\\nvec2 texCoord = gl_FragCoord.xy / uViewSize;\\ntexCoord.y = 1.0 - texCoord.y; // FBOs positions are flipped.\\n\\nvec4 normalColor = texture2D(uNormalSampler, texCoord);\\nnormalColor.g = 1.0 - normalColor.g; // Green layer is flipped Y coords.\\n\\n// bail out early when normal has no data\\nif (normalColor.a == 0.0) discard;\\n\\n\\n    vec2 lightPosition = translationMatrix[2].xy / uViewSize;\\n\\n    // the directional vector of the light\\n    vec3 lightVector = vec3(lightPosition - texCoord, uLightHeight);\\n\\n    // correct for aspect ratio\\n    lightVector.x *= uViewSize.x / uViewSize.y;\\n\\n    // compute Distance\\n    float D = length(lightVector);\\n\\n    // bail out early when pixel outside of light sphere\\n    if (D > uLightRadius) discard;\\n\\n// normalize vectors\\nvec3 N = normalize(normalColor.xyz * 2.0 - 1.0);\\nvec3 L = normalize(lightVector);\\n\\n// pre-multiply light color with intensity\\n// then perform \\\"N dot L\\\" to determine our diffuse\\nvec3 diffuse = (uLightColor.rgb * uLightColor.a) * max(dot(N, L), 0.0);\\n\\n\\n    // calculate attenuation\\n    float attenuation = 1.0 / (uLightFalloff.x + (uLightFalloff.y * D) + (uLightFalloff.z * D * D));\\n\\n// calculate final intesity and color, then combine\\nvec3 intensity = diffuse * attenuation;\\nvec4 diffuseColor = texture2D(uSampler, texCoord);\\nvec3 finalColor = diffuseColor.rgb * intensity;\\n\\ngl_FragColor = vec4(finalColor, diffuseColor.a);\\n\\n}\",\n        // custom uniforms\n        {\n            // height of the light above the viewport\n            uLightRadius:   { type: '1f', value: 1 }\n        }\n    );\n}\n\nPointLightShader.prototype = Object.create(LightShader.prototype);\nPointLightShader.prototype.constructor = PointLightShader;\nmodule.exports = PointLightShader;\n\nPIXI.ShaderManager.registerPlugin('pointLightShader', PointLightShader);\n","/**\n *\n * @class\n * @private\n * @memberof PIXI.lights\n * @extends PIXI.ObjectRenderer\n * @param renderer {WebGLRenderer} The renderer this sprite batch works for.\n */\nfunction LightRenderer(renderer)\n{\n    PIXI.ObjectRenderer.call(this, renderer);\n\n    // the total number of indices in our batch, there are 6 points per quad.\n    var numIndices = LightRenderer.MAX_LIGHTS * 6;\n\n    /**\n     * Holds the indices\n     *\n     * @member {Uint16Array}\n     */\n    this.indices = new Uint16Array(numIndices);\n\n    //TODO this could be a single buffer shared amongst all renderers as we reuse this set up in most renderers\n    for (var i = 0, j = 0; i < numIndices; i += 6, j += 4)\n    {\n        this.indices[i + 0] = j + 0;\n        this.indices[i + 1] = j + 1;\n        this.indices[i + 2] = j + 2;\n        this.indices[i + 3] = j + 0;\n        this.indices[i + 4] = j + 2;\n        this.indices[i + 5] = j + 3;\n    }\n\n    /**\n     * The current size of the batch, each render() call adds to this number.\n     *\n     * @member {number}\n     */\n    this.currentBatchSize = 0;\n\n    /**\n     * The current lights in the batch.\n     *\n     * @member {Light[]}\n     */\n    this.lights = [];\n}\n\nLightRenderer.MAX_LIGHTS = 500;\n\nLightRenderer.prototype = Object.create(PIXI.ObjectRenderer.prototype);\nLightRenderer.prototype.constructor = LightRenderer;\nmodule.exports = LightRenderer;\n\nPIXI.WebGLRenderer.registerPlugin('lights', LightRenderer);\n\n/**\n * Renders the light object.\n *\n * @param light {Light} the light to render\n */\nLightRenderer.prototype.render = function (light)\n{\n    this.lights[this.currentBatchSize++] = light;\n};\n\nLightRenderer.prototype.flush = function ()\n{\n    var renderer = this.renderer,\n        gl = renderer.gl,\n        diffuseTexture = renderer.diffuseTexture,\n        normalsTexture = renderer.normalsTexture,\n        lastShader = null;\n\n    for (var i = 0; i < this.currentBatchSize; ++i)\n    {\n        var light = this.lights[i],\n            shader = light.shader || this.renderer.shaderManager.plugins[light.shaderName];\n\n        if (!light._vertexBuffer)\n        {\n            this._initWebGL(light);\n        }\n\n        // set shader if needed\n        if (shader !== lastShader) {\n            lastShader = shader;\n            renderer.shaderManager.setShader(shader);\n        }\n\n        renderer.blendModeManager.setBlendMode(light.blendMode);\n\n        // set uniforms, can do some optimizations here.\n        shader.uniforms.uViewSize.value[0] = renderer.width;\n        shader.uniforms.uViewSize.value[1] = renderer.height;\n\n        light.worldTransform.toArray(true, shader.uniforms.translationMatrix.value);\n        renderer.currentRenderTarget.projectionMatrix.toArray(true, shader.uniforms.projectionMatrix.value);\n\n        if (light.useViewportQuad) {\n            // update verts to ensure it is a fullscreen quad even if the renderer is resized. This should be optimized\n            light.vertices[2] = light.vertices[4] = renderer.width;\n            light.vertices[5] = light.vertices[7] = renderer.height;\n        }\n\n        light.syncShader(shader);\n\n        shader.syncUniforms();\n\n        // have to set these manually due to the way pixi base shader makes assumptions about texture units\n        gl.uniform1i(shader.uniforms.uSampler._location, 0);\n        gl.uniform1i(shader.uniforms.uNormalSampler._location, 1);\n\n        if (!light.needsUpdate)\n        {\n            // update vertex data\n            gl.bindBuffer(gl.ARRAY_BUFFER, light._vertexBuffer);\n            gl.bufferSubData(gl.ARRAY_BUFFER, 0, light.vertices);\n            gl.vertexAttribPointer(shader.attributes.aVertexPosition, 2, gl.FLOAT, false, 0, 0);\n\n            // bind diffuse texture\n            gl.activeTexture(gl.TEXTURE0);\n            gl.bindTexture(gl.TEXTURE_2D, diffuseTexture.baseTexture._glTextures[gl.id]);\n\n            // bind normal texture\n            gl.activeTexture(gl.TEXTURE1);\n            gl.bindTexture(gl.TEXTURE_2D, normalsTexture.baseTexture._glTextures[gl.id]);\n\n            // update indices\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, light._indexBuffer);\n            gl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER, 0, light.indices);\n        }\n        else\n        {\n            light.needsUpdate = false;\n\n            // upload vertex data\n            gl.bindBuffer(gl.ARRAY_BUFFER, light._vertexBuffer);\n            gl.bufferData(gl.ARRAY_BUFFER, light.vertices, gl.STATIC_DRAW);\n            gl.vertexAttribPointer(shader.attributes.aVertexPosition, 2, gl.FLOAT, false, 0, 0);\n\n            // bind diffuse texture\n            gl.activeTexture(gl.TEXTURE0);\n            gl.bindTexture(gl.TEXTURE_2D, diffuseTexture.baseTexture._glTextures[gl.id]);\n\n            // bind normal texture\n            gl.activeTexture(gl.TEXTURE1);\n            gl.bindTexture(gl.TEXTURE_2D, normalsTexture.baseTexture._glTextures[gl.id]);\n\n            // static upload of index buffer\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, light._indexBuffer);\n            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, light.indices, gl.STATIC_DRAW);\n        }\n\n        gl.drawElements(renderer.drawModes[light.drawMode], light.indices.length, gl.UNSIGNED_SHORT, 0);\n        renderer.drawCount++;\n    }\n\n    this.currentBatchSize = 0;\n};\n\n/**\n * Prepares all the buffers to render this light.\n *\n * @param light {Light} The light object to prepare for rendering.\n */\nLightRenderer.prototype._initWebGL = function (light)\n{\n    var gl = this.renderer.gl;\n\n    // create the buffers\n    light._vertexBuffer = gl.createBuffer();\n    light._indexBuffer = gl.createBuffer();\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, light._vertexBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, light.vertices, gl.DYNAMIC_DRAW);\n\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, light._indexBuffer);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, light.indices, gl.STATIC_DRAW);\n};\n\nLightRenderer.prototype.destroy = function ()\n{\n    \n};\n","/**\n * The WebGLDeferredRenderer draws the scene and all its content onto a webGL enabled canvas. This renderer\n * should be used for browsers that support webGL. This Render works by automatically managing webGLBatchs.\n * So no need for Sprite Batches or Sprite Clouds.\n * Don't forget to add the view to your DOM or you will not see anything :)\n *\n * @class\n * @memberof PIXI.lights\n * @extends PIXI.SystemRenderer\n * @param [width=0] {number} the width of the canvas view\n * @param [height=0] {number} the height of the canvas view\n * @param [options] {object} The optional renderer parameters\n * @param [options.view] {HTMLCanvasElement} the canvas to use as a view, optional\n * @param [options.transparent=false] {boolean} If the render view is transparent, default false\n * @param [options.autoResize=false] {boolean} If the render view is automatically resized, default false\n * @param [options.antialias=false] {boolean} sets antialias. If not available natively then FXAA antialiasing is used\n * @param [options.forceFXAA=false] {boolean} forces FXAA antialiasing to be used over native. FXAA is faster, but may not always lok as great\n * @param [options.resolution=1] {number} the resolution of the renderer retina would be 2\n * @param [options.clearBeforeRender=true] {boolean} This sets if the CanvasRenderer will clear the canvas or\n *      not before the new render pass.\n * @param [options.preserveDrawingBuffer=false] {boolean} enables drawing buffer preservation, enable this if\n *      you need to call toDataUrl on the webgl context.\n */\nfunction WebGLDeferredRenderer(width, height, options)\n{\n    options = options || {};\n\n    this.renderingNormals = false;\n    this.renderingUnlit = false;\n    this._forwardRender = PIXI.WebGLRenderer.prototype.render;\n\n    PIXI.WebGLRenderer.call(this, width, height, options);\n}\n\nWebGLDeferredRenderer.prototype = Object.create(PIXI.WebGLRenderer.prototype);\nWebGLDeferredRenderer.prototype.constructor = WebGLDeferredRenderer;\nmodule.exports = WebGLDeferredRenderer;\n\n/** @lends PIXI.DisplayObject# */\nObject.assign(WebGLDeferredRenderer.prototype, {\n    /**\n     * Initializes the context and necessary framebuffers.\n     */\n    _initContext: function ()\n    {\n        // call parent init\n        PIXI.WebGLRenderer.prototype._initContext.call(this);\n\n        // first create our render targets.\n        this.diffuseTexture = new PIXI.RenderTexture(this, this.width, this.height, null, this.resolution);\n        this.normalsTexture = new PIXI.RenderTexture(this, this.width, this.height, null, this.resolution);\n    },\n\n    // TODO Optimizations:\n    // Only call `updateTransform` once, right now it is call each render pass.\n    // Optimize render texture rendering to reduce duplication, or use render targets directly.\n    // Cache tree transversal, cache elements to use for each render pass?\n\n    render: function (object)\n    {\n        // no point rendering if our context has been blown up!\n        if (this.gl.isContextLost())\n        {\n            return;\n        }\n\n        this.drawCount = 0;\n\n        this._lastObjectRendered = object;\n\n        /////////////\n        //  Rendering\n        this.renderingUnlit = false;\n\n        // render diffuse\n        this.renderingNormals = false;\n        this.diffuseTexture.render(object);\n\n        // render normals\n        this.renderingNormals = true;\n        this.normalsTexture.render(object);\n\n        // render lights\n        this.setRenderTarget(this.renderTarget);\n        this.setObjectRenderer(this.plugins.lights);\n        this.plugins.lights.flush();\n\n        // forward render unlit objects (no normal texture)\n        var cbr = this.clearBeforeRender,\n            draws = this.drawCount;\n\n        this.renderingNormals = false;\n        this.renderingUnlit = true;\n        this.clearBeforeRender = false;\n\n        this._forwardRender(object);\n        this.clearBeforeRender = cbr;\n        this.drawCount += draws;\n        /////////////\n    }\n});\n","/**\n * Creates vertices and indices arrays to describe this circle.\n * \n * @param [totalSegments=40] {number} Total segments to build for the circle mesh.\n * @param [verticesOutput] {Float32Array} An array to output the vertices into. Length must be\n *  `((totalSegments + 2) * 2)` or more. If not passed it is created for you.\n * @param [indicesOutput] {Uint16Array} An array to output the indices into, in gl.TRIANGLE_FAN format. Length must\n *  be `(totalSegments + 3)` or more. If not passed it is created for you.\n */\nPIXI.Circle.prototype.getMesh = function (totalSegments, vertices, indices)\n{\n    totalSegments = totalSegments || 40;\n\n    vertices = vertices || new Float32Array((totalSegments + 1) * 2);\n    indices = indices || new Uint16Array(totalSegments + 1);\n\n    var seg = (Math.PI * 2) / totalSegments,\n        indicesIndex = -1;\n\n    indices[++indicesIndex] = indicesIndex;\n\n    for (var i = 0; i <= totalSegments; ++i)\n    {\n        var index = i*2;\n        var angle = seg * i;\n\n        vertices[index] = Math.cos(angle) * this.radius;\n        vertices[index+1] = Math.sin(angle) * this.radius;\n\n        indices[++indicesIndex] = indicesIndex;\n    }\n\n    indices[indicesIndex] = 1;\n\n    return {\n        vertices: vertices,\n        indices: indices\n    };\n};\n"],"sourceRoot":"./"}